--- a/gui/src/streamsession.cpp
+++ b/gui/src/streamsession.cpp
@@ Description:
@@ AUTO-RECONNECT ON UNEXPECTED DISCONNECT
@@
@@ Problem:
@@   Multiple users report sessions dropping (issues #575, #449, #458, #103, #230).
@@   Currently chiaki-ng just shows an error dialog — user must manually reconnect.
@@   This is especially bad for embedded/launcher use where there's no operator.
@@
@@ Solution:
@@   Add exponential-backoff auto-reconnect when the quit reason is a transient
@@   network error (not user-initiated stop, not server shutdown). Cap at 5 retries
@@   with 1s → 2s → 4s → 8s → 16s backoff. Report status via a new signal so the
@@   GUI (or our Electron wrapper) can show "Reconnecting (attempt 2/5)..."
@@
@@ Files to modify:
@@   gui/include/streamsession.h
@@   gui/src/streamsession.cpp
@@
@@ --- gui/include/streamsession.h ---
@@
@@ Add to the StreamSession class declaration (public section):

    // Auto-reconnect
    static constexpr int MAX_RECONNECT_ATTEMPTS = 5;
    static constexpr int BASE_RECONNECT_DELAY_MS = 1000;

signals:
    void ReconnectAttempt(int attempt, int maxAttempts, int delayMs);
    void ReconnectSucceeded();
    void ReconnectFailed(int attempts);

private:
    int reconnect_attempts = 0;
    bool reconnect_enabled = true;
    QTimer *reconnect_timer = nullptr;

    void scheduleReconnect();
    void attemptReconnect();
    bool isTransientError(ChiakiQuitReason reason);

@@
@@ --- gui/src/streamsession.cpp ---
@@
@@ In the constructor, after existing initialization:

    reconnect_timer = new QTimer(this);
    reconnect_timer->setSingleShot(true);
    connect(reconnect_timer, &QTimer::timeout, this, &StreamSession::attemptReconnect);

@@ In the session quit event handler (where CHIAKI_EVENT_QUIT is processed):
@@ Replace the immediate quit with reconnect logic:

    case CHIAKI_EVENT_QUIT:
    {
        ChiakiQuitReason reason = event->quit.reason;
        QString reason_str = event->quit.reason_str
            ? QString::fromUtf8(event->quit.reason_str) : QString();

        if (reconnect_enabled && isTransientError(reason) &&
            reconnect_attempts < MAX_RECONNECT_ATTEMPTS)
        {
            CHIAKI_LOGI(log.GetChiakiLog(),
                "Transient disconnect (reason: %s), scheduling reconnect attempt %d/%d",
                chiaki_quit_reason_string(reason),
                reconnect_attempts + 1, MAX_RECONNECT_ATTEMPTS);
            scheduleReconnect();
            return; // Don't emit SessionQuit yet
        }

        if (reconnect_attempts > 0)
        {
            CHIAKI_LOGE(log.GetChiakiLog(),
                "Reconnect failed after %d attempts, giving up", reconnect_attempts);
            emit ReconnectFailed(reconnect_attempts);
        }

        // Original quit handling continues here...
        break;
    }

@@ Add new method implementations:

bool StreamSession::isTransientError(ChiakiQuitReason reason)
{
    switch (reason)
    {
    // These are transient — worth retrying
    case CHIAKI_QUIT_REASON_STREAM_CONNECTION_UNKNOWN:
    case CHIAKI_QUIT_REASON_STREAM_CONNECTION_REMOTE_DISCONNECTED:
    case CHIAKI_QUIT_REASON_CTRL_UNKNOWN:
    case CHIAKI_QUIT_REASON_CTRL_CONNECT_FAILED:
        return true;

    // These are intentional or permanent — don't retry
    case CHIAKI_QUIT_REASON_STOPPED:                              // User pressed stop
    case CHIAKI_QUIT_REASON_STREAM_CONNECTION_REMOTE_SHUTDOWN:    // PS going to sleep
    case CHIAKI_QUIT_REASON_CTRL_CONNECTION_REFUSED:              // Auth failure
    case CHIAKI_QUIT_REASON_SESSION_REQUEST_UNKNOWN:
    case CHIAKI_QUIT_REASON_SESSION_REQUEST_CONNECTION_REFUSED:
    case CHIAKI_QUIT_REASON_SESSION_REQUEST_RP_IN_USE:
    case CHIAKI_QUIT_REASON_SESSION_REQUEST_RP_CRASH:
    case CHIAKI_QUIT_REASON_SESSION_REQUEST_RP_VERSION_MISMATCH:
    default:
        return false;
    }
}

void StreamSession::scheduleReconnect()
{
    reconnect_attempts++;
    int delay = BASE_RECONNECT_DELAY_MS * (1 << (reconnect_attempts - 1)); // Exponential backoff
    delay = qMin(delay, 16000); // Cap at 16 seconds

    CHIAKI_LOGI(log.GetChiakiLog(),
        "Will attempt reconnect in %d ms (attempt %d/%d)",
        delay, reconnect_attempts, MAX_RECONNECT_ATTEMPTS);

    emit ReconnectAttempt(reconnect_attempts, MAX_RECONNECT_ATTEMPTS, delay);
    reconnect_timer->start(delay);
}

void StreamSession::attemptReconnect()
{
    CHIAKI_LOGI(log.GetChiakiLog(),
        "Attempting reconnect %d/%d...", reconnect_attempts, MAX_RECONNECT_ATTEMPTS);

    // Stop the old session cleanly
    chiaki_session_stop(&session);
    chiaki_session_join(&session);
    chiaki_session_fini(&session);

    // Re-initialize with the same connect info
    ChiakiErrorCode err = chiaki_session_init(&session, &connect_info, log.GetChiakiLog());
    if (err != CHIAKI_ERR_SUCCESS)
    {
        CHIAKI_LOGE(log.GetChiakiLog(), "Failed to reinitialize session: %s",
            chiaki_error_string(err));
        emit ReconnectFailed(reconnect_attempts);
        return;
    }

    // Re-attach event callback
    chiaki_session_set_event_cb(&session, EventCB, this);

    // Re-attach audio/video sinks (same as original init)
    // ... (reuse the same sink setup from constructor)

    err = chiaki_session_start(&session);
    if (err != CHIAKI_ERR_SUCCESS)
    {
        CHIAKI_LOGE(log.GetChiakiLog(), "Failed to restart session: %s",
            chiaki_error_string(err));
        // The session will fire another quit event, which will
        // trigger the next reconnect attempt via the event handler
        return;
    }

    // Success — the session is running again
    CHIAKI_LOGI(log.GetChiakiLog(), "Reconnect attempt %d started successfully",
        reconnect_attempts);

    // Reset counter on successful stream establishment
    // (We'll reset in the streaminfo received handler)
}

@@ In the streaminfo received handler (where video profiles are logged):
@@ Add reconnect success notification:

    if (reconnect_attempts > 0)
    {
        CHIAKI_LOGI(log.GetChiakiLog(), "Reconnect succeeded after %d attempt(s)",
            reconnect_attempts);
        reconnect_attempts = 0;
        emit ReconnectSucceeded();
    }
