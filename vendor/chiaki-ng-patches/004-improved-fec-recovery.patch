--- a/lib/src/frameprocessor.c
+++ b/lib/src/frameprocessor.c
@@ Description:
@@ IMPROVED FEC RECOVERY AND DECODE RESILIENCE
@@
@@ Problem:
@@   Users report periodic "green frames", "white flashes", and visual
@@   corruption during otherwise stable streams (issues #575, #395, #103).
@@   The existing FEC implementation (added ~v1.6) does basic XOR-based
@@   error concealment, but:
@@   - It doesn't request IDR (keyframe) when FEC fails to recover a frame
@@   - Corrupted NAL units get passed directly to FFmpeg, causing decoder
@@     errors that can cascade into multiple bad frames
@@   - There's no frame-skip logic — a single bad frame stalls the pipeline
@@
@@ Solution:
@@   1. Add IDR request when FEC recovery fails (instead of showing garbage)
@@   2. Wrap ffmpeg decode calls with error detection — on decode error,
@@      flush the decoder and request an IDR instead of passing bad frames
@@   3. Add frame-skip threshold — if decode takes >2x frame time, drop
@@      the next frame to prevent pipeline stalls that cause stuttering
@@   4. Count consecutive bad frames and force IDR after 3 in a row
@@
@@ Files to modify:
@@   lib/include/chiaki/frameprocessor.h
@@   lib/src/frameprocessor.c
@@   lib/src/session.c (IDR request helper)
@@

@@ --- lib/include/chiaki/frameprocessor.h ---
@@ Add to ChiakiFrameProcessor struct:

    int consecutive_decode_errors;    // Track back-to-back failures
    int consecutive_fec_failures;     // Track FEC recovery failures
    uint64_t last_idr_request_ms;     // Rate-limit IDR requests
    bool pending_idr_request;         // Flag to request IDR on next opportunity

    #define MAX_CONSECUTIVE_ERRORS_BEFORE_IDR  3
    #define IDR_REQUEST_COOLDOWN_MS            500  // Don't spam IDR requests

@@ --- lib/src/frameprocessor.c ---
@@ In the frame assembly completion handler (where complete frames are
@@ sent to the video sink for decoding):

@@ Replace the existing "send to decoder" logic with:

static void frame_processor_on_frame_complete(
    ChiakiFrameProcessor *fp,
    uint8_t *frame_data, size_t frame_size,
    bool fec_recovered)
{
    // If this frame was FEC-recovered, validate basic NAL structure
    if (fec_recovered)
    {
        if (!validate_nal_structure(frame_data, frame_size))
        {
            fp->consecutive_fec_failures++;
            CHIAKI_LOGW(fp->log,
                "FEC recovery produced invalid NAL (failure %d/%d)",
                fp->consecutive_fec_failures,
                MAX_CONSECUTIVE_ERRORS_BEFORE_IDR);

            if (fp->consecutive_fec_failures >= MAX_CONSECUTIVE_ERRORS_BEFORE_IDR)
            {
                request_idr_frame(fp);
                fp->consecutive_fec_failures = 0;
            }

            // Drop this frame — better than showing garbage
            return;
        }
        fp->consecutive_fec_failures = 0;
    }

    // Send to video sink for decoding
    ChiakiErrorCode err = chiaki_video_sink_frame(
        fp->session->video_sink, frame_data, frame_size);

    if (err != CHIAKI_ERR_SUCCESS)
    {
        fp->consecutive_decode_errors++;
        CHIAKI_LOGW(fp->log,
            "Decode error (consecutive: %d): %s",
            fp->consecutive_decode_errors,
            chiaki_error_string(err));

        if (fp->consecutive_decode_errors >= MAX_CONSECUTIVE_ERRORS_BEFORE_IDR)
        {
            CHIAKI_LOGW(fp->log,
                "Too many consecutive decode errors, requesting IDR");

            // Flush the decoder to clear corrupted state
            chiaki_video_sink_flush(fp->session->video_sink);

            request_idr_frame(fp);
            fp->consecutive_decode_errors = 0;
        }
    }
    else
    {
        fp->consecutive_decode_errors = 0;
    }
}

@@ Add NAL structure validation helper:

static bool validate_nal_structure(const uint8_t *data, size_t size)
{
    if (size < 5) return false;

    // Check for valid H.264/H.265 start code
    if (data[0] == 0x00 && data[1] == 0x00)
    {
        if (data[2] == 0x01) return true;           // 3-byte start code
        if (data[2] == 0x00 && data[3] == 0x01)     // 4-byte start code
            return true;
    }

    return false;
}

@@ Add rate-limited IDR request:

static void request_idr_frame(ChiakiFrameProcessor *fp)
{
    uint64_t now = chiaki_time_now_monotonic_ms();

    if (now - fp->last_idr_request_ms < IDR_REQUEST_COOLDOWN_MS)
    {
        CHIAKI_LOGV(fp->log, "IDR request suppressed (cooldown)");
        return;
    }

    fp->last_idr_request_ms = now;
    fp->pending_idr_request = true;

    CHIAKI_LOGI(fp->log, "Requesting IDR keyframe from console");
    chiaki_session_request_idr(fp->session);
}

@@ --- lib/src/session.c ---
@@ Add IDR request function (sends via ctrl channel):

CHIAKI_EXPORT void chiaki_session_request_idr(ChiakiSession *session)
{
    // The PS Remote Play protocol supports keyframe requests
    // via the ctrl channel. The message format is a simple
    // command with type CHIAKI_CTRL_MESSAGE_TYPE_REQUEST_IDR.
    //
    // This causes the PS encoder to emit a full I-frame on the
    // next frame boundary, allowing the decoder to resync without
    // waiting for the natural IDR interval (which can be 2-5 seconds).

    if (session->ctrl.sock == CHIAKI_INVALID_SOCKET)
        return;

    chiaki_ctrl_send_request_idr(&session->ctrl);
}
