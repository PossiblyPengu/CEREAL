--- a/gui/src/main.cpp
+++ b/gui/src/main.cpp
@@ Description:
@@ LAUNCHER INTEGRATION MODE (--cereal-mode)
@@
@@ Problem:
@@   When embedded in Cereal launcher, we spawn chiaki.exe as a subprocess.
@@   But the current launch flow has friction:
@@   - The Qt GUI always opens (even with `stream` CLI command), showing a
@@     window briefly before the streaming window takes over
@@   - No way to signal the parent process when streaming actually starts
@@   - No graceful "return to launcher" — quit means quit
@@   - --exit-app-on-stream-exit was added in v1.9.9 but doesn't signal WHY
@@   - No way to pass auth tokens or pre-registered console info via CLI
@@
@@ Solution:
@@   Add --cereal-mode flag that activates launcher-friendly behavior:
@@
@@   1. --cereal-mode: Combines --fullscreen, --json-status, and
@@      --exit-app-on-stream-exit into a single flag
@@   2. --regist-key=<key>: Accept registration key via CLI (no GUI needed)
@@   3. --morning=<token>: Accept auth token via CLI
@@   4. --exit-code-reason: Set process exit code based on quit reason:
@@      0 = clean exit (user stopped or server shutdown)
@@      1 = transient error (reconnectable)
@@      2 = auth error (registration needed)
@@      3 = console not found
@@      This lets the Electron parent process decide what to do next.
@@   5. Suppress the initial Qt window flash entirely
@@
@@ Files to modify:
@@   gui/src/main.cpp
@@   gui/include/streamsession.h
@@

@@ --- gui/src/main.cpp ---
@@ In argument parsing:

    bool cereal_mode = false;
    const char *regist_key = nullptr;
    const char *morning_token = nullptr;

    for (int i = 1; i < argc; i++)
    {
        if (strcmp(argv[i], "--cereal-mode") == 0)
        {
            cereal_mode = true;
            json_status = true;      // Implies --json-status
            fullscreen = true;       // Implies --fullscreen
            exit_on_stream_exit = true; // Implies --exit-app-on-stream-exit
            continue;
        }
        if (strncmp(argv[i], "--regist-key=", 13) == 0)
        {
            regist_key = argv[i] + 13;
            continue;
        }
        if (strncmp(argv[i], "--morning=", 10) == 0)
        {
            morning_token = argv[i] + 10;
            continue;
        }
    }

@@ When cereal_mode is active and we have a stream target:
@@ Skip the discovery GUI entirely and go straight to streaming:

    if (cereal_mode && stream_host)
    {
        // Don't show the main GUI window at all
        // Build connect info directly from CLI args
        ChiakiConnectInfo connect_info = {};
        // ... populate from stream_host, regist_key, morning_token, etc.

        // Create a minimal QWindow for rendering (no Qt chrome)
        // This avoids the "window flash" that happens with the full QML UI

        StreamSession *session = new StreamSession(connect_info, ...);

        QObject::connect(session, &StreamSession::SessionQuit,
            [&](ChiakiQuitReason reason, const QString &reason_str) {

            int exit_code = 0;
            if (chiaki_quit_reason_is_error(reason))
            {
                switch (reason)
                {
                case CHIAKI_QUIT_REASON_CTRL_CONNECTION_REFUSED:
                case CHIAKI_QUIT_REASON_SESSION_REQUEST_CONNECTION_REFUSED:
                    exit_code = 2; // Auth error
                    break;
                case CHIAKI_QUIT_REASON_NONE:
                    exit_code = 3; // Console not found
                    break;
                default:
                    exit_code = 1; // Transient
                    break;
                }
            }

            QCoreApplication::exit(exit_code);
        });

        session->Start();
        return app.exec();
    }

@@ --- Electron-side usage (main.js) ---
@@ The launcher reads these exit codes to decide next action:

    // When launching via chiaki:
    const child = spawn(chiakiExe, [
        '--cereal-mode',
        'stream', nickname, host,
        `--regist-key=${registKey}`,
        `--morning=${morningToken}`,
    ], { cwd: chiakiDir, env });

    // Read JSON status events from stdout
    child.stdout.on('data', (data) => {
        const lines = data.toString().split('\n').filter(Boolean);
        for (const line of lines) {
            try {
                const event = JSON.parse(line);
                mainWindow.webContents.send('chiaki:event', event);

                if (event.event === 'streaming') {
                    mainWindow.webContents.send('chiaki:streaming', event);
                }
                if (event.event === 'quality') {
                    // Update quality overlay in launcher
                    mainWindow.webContents.send('chiaki:quality', event);
                }
            } catch (e) { /* ignore non-JSON log lines */ }
        }
    });

    // Handle exit codes
    child.on('exit', (code) => {
        switch (code) {
            case 0: // Clean exit — return to launcher
                break;
            case 1: // Transient error — offer retry
                mainWindow.webContents.send('chiaki:error', {
                    type: 'transient',
                    message: 'Connection lost. Retry?'
                });
                break;
            case 2: // Auth error — need re-registration
                mainWindow.webContents.send('chiaki:error', {
                    type: 'auth',
                    message: 'Console registration expired. Please re-register.'
                });
                break;
            case 3: // Console not found
                mainWindow.webContents.send('chiaki:error', {
                    type: 'not_found',
                    message: 'PlayStation not found. Is it on or in rest mode?'
                });
                break;
        }
    });
